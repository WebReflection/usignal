/*! (c) Andrea Giammarchi */
const{is:s}=Object;let t;const e=s=>{const e=t;t=e||[];try{if(s(),!e)for(const s of t)s()}finally{t=e}};class i{constructor(s){this._=s}then(){return this.value}toJSON(){return this.value}toString(){return this.value}valueOf(){return this.value}}let h,n=!0;class o extends i{constructor(s,t,e,i){super(s),this.f=i,this.$=!0,this.r=new Set,this.s=new y(t,e)}get value(){if(this.$)if(n){const s=h;h=this,this.r.clear();try{this.s.value=this._(this.s._)}finally{this.$=!1,h=s}}else{this.$=!1;try{this.s._=this._(this.s._)}finally{this.$=!1}}return this.s.value}}const c={async:!1,equals:!0},r=(s,t,e=c)=>new o(s,t,e,!1);let l;const u=()=>{},a=s=>{for(const t of s)t.stop()};class f extends o{constructor(s,t,e){super(s,t,e,!0),this.i=0,this.a=!!e.async,this.m=!0,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const s=l;l=this,this.i=0;const{length:t}=this.e;super.value,this.i<t&&a(this.e.splice(this.i));for(const{value:s}of this.e);l=s}stop(){this._=u,this.r.clear(),this.s.c.clear(),this.e.length&&a(this.e.splice(0))}}const v=(s,t,e=c)=>{let i;if(l){const{i:h,e:n}=l;h!==n.length&&n[h]._===s||(n[h]=new f(s,t,e)),i=n[h],l.i++}else(i=new f(s,t,e)).value;return()=>{i.stop()}},p=()=>!1;class y extends i{constructor(t,{equals:e}){super(t),this.c=new Set,this.s=!0===e?s:e||p}peek(){return this._}get value(){return h&&(this.c.add(h),h.r.add(this)),this._}set value(s){if(!this.s(this._,s)){this._=s;const e=[],i=[],h=[this];for(const s of h)for(const t of s.c)if(!t.$&&t.r.has(s))if(t.$=!0,t.f){e.push(t);const s=[t];for(const t of s)for(const e of t.e)e.$=!0,s.push(e)}else h.push(t.s),i.push(t);const o=n;n=!1;for(const{value:s}of i);n=o;for(const s of e)t?t.push((()=>{s.value})):s.value}}}const _=(s,t=c)=>new y(s,t);export{i as Signal,e as batch,r as computed,v as effect,_ as signal};
