/*! (c) Andrea Giammarchi */
const{is:s}=Object;let t;const e=s=>{const e=t;t=e||[];try{if(s(),!e)for(const{value:s}of t);}finally{t=e}};class i{constructor(s){this._=s}toJSON(){return this.value}toString(){return String(this.value)}valueOf(){return this.value}}let r;class n extends i{s;constructor(s,t,e,i){super(s),this.f=i,this.$=!0,this.r=new Set,this.s=new _(t,e)}refresh(){if(!this.$)return;const s=r;r=this;try{this.s.value=this._(this.s._)}finally{this.$=!1,r=s}}peek(){return this.refresh(),this.s.peek()}get value(){return this.refresh(),this.s.value}}const h={async:!1,equals:!0},o=(s,t,e=h)=>new n(s,t,e,!1);let c;const u=[],a=()=>{},l=({s:s})=>{"function"==typeof s._&&(s._=s._())};class f extends n{constructor(s,t,e){super(s,t,e,!0),this.e=u}run(){return this.$=!0,this.value,this}stop(){this._=a,this.r.clear(),this.s.c.clear()}}class p extends f{constructor(s,t,e){super(s,t,e),this.i=0,this.a=!!e.async,this.m=!0,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const s=c;(c=this).i=0,l(this),super.value,c=s}stop(){super.stop(),l(this);for(const s of this.e.splice(0))s.stop()}}const v=(s,t,e=h)=>{let i;if(c){const{i:r,e:n}=c,h=r===n.length;(h||n[r]._!==s)&&(h||n[r].stop(),n[r]=new p(s,t,e).run()),i=n[r],c.i++}else i=new p(s,t,e).run();return()=>{i.stop()}},y=()=>!1;class _ extends i{constructor(t,{equals:e}){super(t),this.c=new Set,this.s=!0===e?s:e||y}peek(){return this._}get value(){return r&&(this.c.add(r),r.r.add(this)),this._}set value(s){const e=this._;if(!this.s(this._=s,e)&&this.c.size){const s=[],e=[this];for(const t of e)for(const i of t.c)if(!i.$&&i.r.has(t))if(i.r.clear(),i.$=!0,i.f){s.push(i);const t=[i];for(const s of t)for(const e of s.e)e.r.clear(),e.$=!0,t.push(e)}else e.push(i.s);for(const e of s)t?t.push(e):e.value}}}const d=(s,t=h)=>new _(s,t);export{p as Effect,f as FX,i as Signal,e as batch,o as computed,v as effect,d as signal};
